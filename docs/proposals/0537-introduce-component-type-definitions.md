# Introduce Component Type Definitions

**Authors**:
@ChathurangaKCD

**Reviewers**:

**Created Date**:
2025-10-17

**Status**:
Submitted

**Related Issues/PRs**:
[Issue #537 â€“ openchoreo/openchoreo](https://github.com/openchoreo/openchoreo/issues/537)

---

## Summary

This proposal introduces **ComponentTypeDefinitions with Addons** to replace OpenChoreo's current rigid component types (Services, WebApps, ScheduledTasks). The new approach enables platform engineers to define atomic, composable component types using CEL-based templates that stay close to Kubernetes primitives, while addons provide reusable cross-cutting capabilities. This design maintains a simplified developer experience through a single Component CRD while giving platform engineers full control and extensibility.

---

## Motivation

OpenChoreo's current component types (**Services**, **WebApps**, and **ScheduledTasks**) provide developer-centric abstractions where developers have direct control over the entire Deployment specification. While this gives developers flexibility, it creates several challenges:

- **Over-abstraction from Kubernetes APIs**: Current component types mask native Kubernetes resources, making the mental model harder for Kubernetes-savvy users to understand OpenChoreo's Components.

- **Limited platform engineer control**: ComponentClasses can only override portions of developer-defined Deployment specs. Platform engineers cannot enforce organizational policies, resource limits, or deployment configurations as templates that developers instantiate.

- **No composition model**: Platform engineers cannot define their own component types by combining Kubernetes primitives, OpenChoreo concepts, and external CRDs of other tools they may be using.

- **No environment-specific overrides**: There is no way to override or patch environment-specific parameters (like resource limits or replica counts) in a structured, validated manner.

As a result, platform engineers lack the control needed to enforce organizational standards, and they may be forced to bypass OpenChoreo entirely if their requirements do not fit into one of OpenChoreo's opinionated component types.

---

## Goals

- **Extensibility**: Platform engineers can model organizational needs without forking or bypassing OpenChoreo. Addons enable cross-cutting capabilities (storage, networking, security) to be reused across component types.

- **Alignment with Kubernetes**: Reduces friction by staying consistent with native APIs, making it easier for Kubernetes-savvy teams to understand and adopt OpenChoreo.

- **Developer Experience**: Developers get a consistent, simplified interface (single Component CRD) with guardrails, while platform engineers retain full control. OpenChoreo's developer abstractions like endpoints, connections and config schemas are retained without restricting PE control.

- **Reusability**: Define ComponentTypeDefinitions and Addons once, compose them in multiple ways across different components.

---

## Non-Goals

- **Replace Kubernetes primitives**: This proposal does not aim to abstract away or replace Kubernetes resources. Instead, it works with them to provide a higher-level interface while maintaining compatibility.

- **Support multiple primary workload resources**: Each ComponentTypeDefinition is limited to a single primary workload resource. The ComponentTypeDefinition must declare a `workloadType` field (one of: `deployment`, `statefulset`, `cronjob`, `job`), and the primary workload resource's `id` must match this `workloadType`. Additional supporting resources (Services, HPAs, PDBs, etc.) can be defined in the resources section and via addons.

---

## Impact

This proposal introduces new CRDs and controller support:

- New CRDs: `ComponentTypeDefinition` (v1alpha1), `Addon` (v1alpha1), and `ComponentDeployment` (v1alpha1)
- New `v1alpha1` version of the `Component` CRD with `componentType` and `addons[]` fields
- New controllers for rendering ComponentTypeDefinitions with CEL templating and applying addon composition

---

## Design

### Overview

This design introduces three core mechanisms explained below with concrete examples:

### 1. Template-Based ComponentTypeDefinitions

ComponentTypeDefinitions use templates to generate Kubernetes resources dynamically, staying close to native K8s APIs while adding parameterization.

- Instead of static YAML, use **CEL (Common Expression Language)** templates that pull data from multiple sources, including developer inputs, the workload spec, and references to all resources defined within the template.

- Types, validations and expressions from CEL allow UIs to be autogenerated from the template, enabling dynamic forms for these resources in the OpenChoreo portal (and in the CLI).

- **Workload Type Constraint**: Each ComponentTypeDefinition must explicitly declare a `workloadType` (one of: `deployment`, `statefulset`, `cronjob`, `job`). The ComponentTypeDefinition must define exactly one primary workload resource whose `id` matches the declared `workloadType`. Additional supporting resources (Service, HPA, PDB, etc.) can be included in the resources section. When creating a Component, the `componentType` field uses the format `{workloadType}/{componentTypeDefinitionName}` (e.g., `deployment/web-app`).

```yaml
apiVersion: openchoreo.dev/v1alpha1
kind: ComponentTypeDefinition
metadata:
  name: web-app
  namespace: default
spec:
  # Workload type - must be one of: deployment, statefulset, cronjob, job
  workloadType: deployment

  # Schema defines what developers can configure
  schema:
    parameters:
      # Static across environments and exposed as inputs to the developer when creating a Component of this type.
      # Examples provided after Component definition section.

    envOverrides:
      # Defaults can be provided when creating a Component (optional).
      # Can be overridden per environment via ComponentDeployment.
      # Examples provided after Component definition section.

  # Templates generate K8s resources dynamically
  resources:
    - id: deployment
      template:
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: ${metadata.name}
        spec:
          selector:
            matchLabels: |
              ${metadata.podSelectors}
          template:
            metadata:
              labels: |
                ${merge({"app": metadata.name}, metadata.podSelectors)}
            spec:
              terminationGracePeriodSeconds: ${parameters.lifecycle.terminationGracePeriodSeconds}
              containers:
                - name: app
                  image: ${build.image}
                  imagePullPolicy: ${parameters.lifecycle.imagePullPolicy}
                  command: ${parameters.runtime.command}
                  args: ${parameters.runtime.args}
                  ports: |
                    ${workload.endpoints.map(e, {"containerPort": e.port})}
                  resources:
                    requests:
                      cpu: ${parameters.resources.requests.cpu}
                      memory: ${parameters.resources.requests.memory}
                    limits:
                      cpu: ${parameters.resources.limits.cpu}
                      memory: ${parameters.resources.limits.memory}

    - id: hpa
      includeWhen: ${parameters.autoscaling.enabled}
      template:
        apiVersion: autoscaling/v2
        kind: HorizontalPodAutoscaler
        metadata:
          name: ${metadata.name}
        spec:
          scaleTargetRef:
            apiVersion: apps/v1
            kind: Deployment
            name: ${metadata.name}
          minReplicas: ${parameters.autoscaling.minReplicas}
          maxReplicas: ${parameters.autoscaling.maxReplicas}
          metrics:
            - type: Resource
              resource:
                name: cpu
                target:
                  type: Utilization
                  averageUtilization: ${parameters.autoscaling.targetCPUUtilization}

    - id: pdb
      includeWhen: ${parameters.autoscaling.enabled}
      template:
        apiVersion: policy/v1
        kind: PodDisruptionBudget
        metadata:
          name: ${metadata.name}
        spec:
          selector:
            matchLabels:
              app: ${metadata.name}
          minAvailable: 1
```

**Key insight:** Templates access data from different sources at different times:

- `${metadata.name}` - Component instance name
- `${metadata.namespace}` - Component instance namespace
- `${metadata.labels}` - Component instance labels
- `${metadata.annotations}` - Component instance annotations
- `${metadata.podSelectors}` - Platform-injected pod selectors (e.g., `openchoreo.io/component-id`, `openchoreo.io/environment`, `openchoreo.io/project-id`) for component identity and environment tracking
- `${parameters.*}` - Developer configuration from Component (merged parameters + envOverrides)
- `${build.*}` - Build context from Component's build field
- `${workload.*}` - Application metadata extracted from source repo at build time

**forEach support for generating multiple resources:**

ComponentTypeDefinitions support `forEach` to generate multiple instances of a resource template. This is useful for scenarios like creating multiple ConfigMaps from a list of configurations:

```yaml
resources:
  - id: config
    forEach: ${parameters.configurations}
    var: config
    template:
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: ${metadata.name}-${config.name}
      data: |
        ${config.data}
```

In this example, if the controller injects configurations into the template context:

```yaml
configurations:
  - name: app-config
    data:
      LOG_LEVEL: "info"
      FEATURE_FLAG: "enabled"
  - name: db-config
    data:
      DB_HOST: "postgres.default.svc"
      DB_PORT: "5432"
```

The system will generate two ConfigMaps: `checkout-service-app-config` and `checkout-service-db-config`, each with their respective data.

### 2. Addons for Composability

- Addons are atomic, reusable units that modify or augment the underlying Kubernetes resources without requiring separate component type definitions for every variation.
- This avoids combinatorial explosion of rigid component types (no need for "web-app-with-pvc" vs "web-app-with-X", instead PEs can define their own addons that developers can compose into their Components for cross-cutting capabilities).
- OpenChoreo can provide a set of pre-built Addons for common use cases, and PEs can write their own as well. Developers should be able to discover these via the OpenChoreo console/CLI.

Addons can:

- **Create** new resources (PVCs & Volumes, PDBs, ResourceQuotas, Certificates, etc.)
- **Modify (patch)** existing resources (add volumes, sidecars, init containers, topology spread constraints, pod security policies, etc)

### 3. Component CRD - Single Unified Resource

Instead of generating multiple CRDs, developers use a single **Component** CRD with a `componentType` field and `addons[]` array:

```yaml
apiVersion: openchoreo.dev/v1alpha1
kind: Component
metadata:
  name: checkout-service
spec:
  # Select which ComponentTypeDefinition to use (format: {workloadType}/{componentTypeDefinitionName})
  componentType: deployment/web-app

  # Parameters from ComponentTypeDefinition (oneOf schema based on componentType).
  # Env overridable fields also can be set here as defaults.
  parameters:
    lifecycle:
      terminationGracePeriodSeconds: 60
      imagePullPolicy: IfNotPresent
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
      limits:
        cpu: 1000m
        memory: 1Gi
    autoscaling:
      enabled: false
      minReplicas: 2
      maxReplicas: 10
      targetCPUUtilization: 80

  # Addon instances (developer chooses which addons to use)
  addons:
    # Create PVC and add volume to pod
    - name: persistent-volume-claim
      instanceName: app-data
      parameters:
        volumeName: app-data-vol
        mountPath: /app/data
        size: 50Gi
        storageClass: fast

    # Add logging sidecar for file-based logs
    - name: add-file-logging-sidecar
      instanceName: app-logs
      parameters:
        logFilePath: /var/log/app/application.log
        containerName: app

  # Build field (added to CRD schema by OpenChoreo, populated by developer)
  build:
    repository:
      url: https://github.com/myorg/checkout-service
      revision:
        branch: main
      appPath: .
    templateRef:
      name: docker
      parameters:
        - name: docker-context
          value: .
        - name: dockerfile-path
          value: ./Dockerfile
```

**Component CRD Schema:**

The Component CRD uses a **oneOf schema** for the `parameters` field based on the `componentType`:

- When `componentType: web-app`, the `parameters` field schema is the **merged schema** of the ComponentTypeDefinition's `parameters` and `envOverrides`
- This allows developers to configure both static parameters and environment-overridable settings in one place
- At runtime, these are split: `parameters` remain static, `envOverrides` can be overridden in ComponentDeployment
- Templates access merged values via `${parameters.*}` (e.g., `${parameters.lifecycle.terminationGracePeriodSeconds}`, `${parameters.resources.requests.cpu}`)

**Workload Spec (extracted from source repo at build time):**

- The workload spec will be a developer-facing resource that's committed to the application's source repository (as the "workload.yaml").
- This will contain OpenChoreo developer concepts like `endpoints`, `connections`, and `config schema(?)` and will be processed by the system and used as (automatic) inputs to the ComponentTypeDefinitions when composing the final Kubernetes resources.

```yaml
# workload.yaml in source repo
endpoints:
  - name: api
    type: http
    port: 8080
    schemaPath: ./openapi/api.yaml

connections:
  - name: productcatalog
    type: api
    params:
      projectName: gcp-microservice-demo
      componentName: productcatalog
      endpoint: grpc-endpoint
    inject:
      env:
        - name: PRODUCT_CATALOG_SERVICE_ADDR
          value: "{{ .host }}:{{ .port }}"
configSchema: ... # Design TBD
```

This workload spec is available as `${workload.*}` in ComponentTypeDefinition templates, so that PEs can also build additional capabilities based on the values provided here by the developers.

#### Schema Definition Flexibility

ComponentTypeDefinitions and Addons use a concise shorthand schema syntax that allows platform engineers to define type-safe, validated parameters. This shorthand notation provides an intuitive way to express schemas inline within YAML definitions, which are converted to JSON Schema for runtime validation.

**Schema Extraction**: The shorthand schemas are automatically converted to standard JSON Schemas at runtime using OpenChoreo's schema extraction mechanism. This provides the foundation for:
- Type validation for developer inputs
- Auto-generation of UI forms on UI

**Supported Features**:

The schema syntax supports a rich set of capabilities for defining component parameters:

- **Primitive types**: `string`, `integer`, `number`, `boolean`
- **Reusable custom types**: Define types once in a `types` section and reference them across multiple fields
- **Arrays**: Using `[]Type` syntax (e.g., `[]string`, `[]MountInfo`)
- **Maps**: Using `map<ValueType>` syntax for key-value pairs with string keys
- **Nested objects**: Define structured schemas with nested properties inline
- **Constraints and validation**: Rich set of validation markers including `default`, `required`, `enum`, `minimum`, `maximum`, `minLength`, `maxLength`, `pattern`, `nullable`, and more
- **Documentation**: Add `description` marker to provide inline documentation
- **Custom markers**: Support for custom markers that are ignored during schema validations but can be used by tooling (e.g., CLI scaffolding can use custom markers to skip less important optional fields when generating component manifests)

**Example ComponentTypeDefinition with schema definitions:**

```yaml
schema:
  # Optional types section for reusable type definitions
  types:
    ResourceSpec:
      cpu: string | default=100m
      memory: string | default=256Mi

  parameters:
    # Component-level parameters - static across environments
    runtime:
      command: []string | default=[]
      args: []string | default=[]
    lifecycle:
      terminationGracePeriodSeconds: integer | default=30 minimum=1 maximum=300
      imagePullPolicy: string | default=IfNotPresent enum=Always,IfNotPresent,Never
    labels: map<string> | default={}

  envOverrides:
    # Environment-overridable parameters
    resources:
      requests: ResourceSpec
      limits: ResourceSpec
    autoscaling:
      enabled: boolean | default=false
      minReplicas: integer | default=1 minimum=1
      maxReplicas: integer | default=10 minimum=1
      targetCPUUtilization: integer | default=80 minimum=1 maximum=100
```

**How it works**: When a ComponentTypeDefinition is registered, the schema extractor processes the shorthand notation and generates a full JSON Schema. This schema is then used to validate Component definitions and generate user interfaces. The shorthand format significantly reduces verbosity while maintaining expressiveness and type safety.

**Example Addon 1: Persistent Volume Claim with Mount** - A PE defined Addon that allows developers to add a persistent volume mount to a Component.

```yaml
apiVersion: openchoreo.dev/v1alpha1
kind: Addon
metadata:
  name: add-volume-mount
  namespace: default
spec:
  schema:
    parameters: # Developer-facing parameters
      volumeName: string | required=true
      mountPath: string | required=true # Developer decides where in the container to mount the volume
      containerName: string # Which container to mount

    envOverrides: # Platform engineers can override per environment
      size: string | default=10Gi
      storageClass: string | default=standard

  creates:
    - template:
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: ${metadata.name}-${instanceName}
        spec:
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: ${parameters.size}
          storageClassName: ${parameters.storageClass}

  patches:
    # Attach PVC as a volume in the pod spec
    - target:
        group: apps
        version: v1
        kind: Deployment
      operations:
        - op: add
          path: /spec/template/spec/volumes/-
          value:
            name: ${parameters.volumeName}
            persistentVolumeClaim:
              claimName: ${metadata.name}-${instanceName}

    # Mount the PVC into the developer-specified container at the mountPath
    - target:
        group: apps
        version: v1
        kind: Deployment
      operations:
        - op: add
          path: /spec/template/spec/containers/[?(@.name=='${parameters.containerName}')]/volumeMounts/-
          value:
            name: ${parameters.volumeName}
            mountPath: ${parameters.mountPath}
```

**Example Addon 2: EmptyDir Volume with Sidecar** - Allows legacy applications to stream their file based logs to stdout for log collection.

```yaml
apiVersion: openchoreo.dev/v1alpha1
kind: Addon
metadata:
  name: add-file-logging-sidecar
  namespace: default
spec:
  displayName: "Stream File Logs to Stdout"
  description: "Pushes logs from a log file to stdout so that logs will be collected by the system"

  schema:
    parameters:
      logFilePath: string | required=true
      containerName: string # Which container to mount to (defaults to app)

  patches:
    - target:
        group: apps
        version: v1
        kind: Deployment
      operations:
        # Inject sidecar container
        - op: add
          path: /spec/template/spec/containers/-
          value:
            name: log-sidecar
            image: busybox
            command: ["/bin/sh", "-c"]
            args:
              - |
                echo "Starting log tail for ${parameters.logFilePath}"
                tail -n+1 -F ${parameters.logFilePath}
            volumeMounts:
              - name: app-logs
                mountPath: /logs

        # Ensure main container has log volume
        - op: add
          path: /spec/template/spec/containers/[?(@.name=='${parameters.containerName}')]/volumeMounts/-
          value:
            name: app-logs
            mountPath: /logs

        # Add volume for log directory (shared between app + sidecar)
        - op: add
          path: /spec/template/spec/volumes/-
          value:
            name: app-logs
            emptyDir: {}
```

### Step 4: Environment-Specific Overrides

- As both `ComponentTypeDefinitions` and `Addons` define `envOverrides` fields, this `ComponentDeployment` resource targeting a particular `Environment` can override the default values that need to be adjusted for a given environment.
- This is a more structured, strongly-typed and validate-able UX for the PE as opposed to using something like Kustomize patches.

**Example: ComponentDeployment for the `production` environment for a component named "checkout-service"**

```yaml
apiVersion: openchoreo.dev/v1alpha1
kind: ComponentDeployment
metadata:
  name: checkout-service-prod
spec:
  owner:
    componentName: checkout-service
  environment: production

  # Override values in the Component for this environment.
  # These fields are defined in the ComponentTypeDefinition's envOverrides section that instantiated this component.
  overrides:
    resources:
      requests:
        cpu: 500m
        memory: 1Gi
      limits:
        cpu: 2000m
        memory: 2Gi
    autoscaling:
      enabled: true
      minReplicas: 5
      maxReplicas: 50
      targetCPUUtilization: 70

  # Override addon values for the environment (keyed by instanceName).
  # These fields are defined in the addon's envOverrides section.
  addonOverrides:
    app-data: # instanceName
      size: 200Gi # Much larger in prod
      storageClass: premium
```

### Addon Patch Syntax

Addons apply changes to rendered resources through patch documents that mirror Kustomizeâ€™s patch format: each entry selects a resource and runs one or more operations against JSON Pointerâ€“style paths. The standard JSON Patch verbs (`add`, `replace`) are delegated to the upstream `json-patch` engine, while `mergeShallow` is a openchoreo-specific convenience that overlays top-level map keys without replacing sibling values. This balance gives authors familiar semantics with a minimal set of extensions tailored for addon composition.

- **Resource targeting**: Every patch specifies a `target` block. Alongside the resourceâ€™s `group/version/kind`, addons can carry an optional CEL-based `where` predicate to limit the patch to specific instances. Paths themselves follow standard JSON Pointer notation.

  ```yaml
  patches:
    - target:
        group: external-secrets.io
        version: v1beta1
        kind: ExternalSecretStore
        where: ${resource.metadata.name.endsWith("-secret-envs")}
      operations:
        - op: add
          path: /spec/refreshInterval
          value: "5m"
  ```

- **List iteration**: The top-level `forEach` field repeats a patch block for every item in a CEL-evaluated list. A companion `var` key is required to name the binding used inside the operations. Array filters (`[?(@.field=='value')]`) are available on every pathâ€”not just inside loopsâ€”and this example shows the binding selecting the matching container inline.

  ```yaml
  patches:
    - forEach: ${parameters.mounts}
      var: mount
      target:
        group: apps
        version: v1
        kind: Deployment
      operations:
        - op: add
          path: /spec/template/spec/containers/[?(@.name=='${mount.containerName}')]/volumeMounts/-
          value:
            name: ${parameters.volumeName}
            mountPath: ${mount.mountPath}
            readOnly: ${has(mount.readOnly) ? mount.readOnly : false}
            subPath: ${has(mount.subPath) ? mount.subPath : ""}
  ```

- **Shallow map overlays**: Use `mergeShallow` to add or replace specific keys within metadata maps without re-sending the entire payload.

  ```yaml
  patches:
    - target:
        group: apps
        version: v1
        kind: Deployment
      operations:
        - op: mergeShallow
          path: /spec/template/metadata/annotations
          value:
            custom.annotation/foo: foo
            custom.annotation/bar: bar
  ```

## Deployment Flow and Environment Promotion

OpenChoreo separates **promotable content** from **environment-specific overrides** to enable safe, auditable deployments across environments. This uses ComponentDeployment (introduced earlier) along with **ComponentEnvSnapshot**, a new resource containing full copies of ComponentTypeDefinition, Component, Addons, and Workload.

### How It Works

**Deployment**: When a Component, ComponentTypeDefinition, Addon, or Workload is updated, a ComponentEnvSnapshot is created or updated in the first environment of the deployment pipeline. The snapshot is rendered with that environment's ComponentDeployment to produce a Release containing final Kubernetes manifests. Changes to either the snapshot or ComponentDeployment trigger Release updates.

**Promotion**: Promotion copies the snapshot content to a target environment, where it's rendered with that environment's ComponentDeployment. The same snapshot content produces different Releases based on each environment's settings (e.g., 1 replica in dev, 10 in prod).

**Key Constraint**: Changes are automatically deployed only to the first environment. Other environments remain stable until explicitly promoted.

### Benefits

This separation provides clear boundaries between promotable content and environment-specific configuration, enforces progressive rollout workflows, and ensures identical component definitions across environments with only intentional configuration differences.

### ComponentEnvSnapshot Structure

```yaml
apiVersion: openchoreo.dev/v1alpha1
kind: ComponentEnvSnapshot
metadata:
  name: checkout-service-dev
spec:
  owner:
    componentName: checkout-service
  environment: production

  # Full embedded copies (not references!)
  componentTypeDefinition:
    apiVersion: openchoreo.dev/v1alpha1
    kind: ComponentTypeDefinition
    metadata:
      name: web-app
      namespace: default
    spec:
      workloadType: deployment
      schema: { ... }
      resources: { ... }

  component:
    apiVersion: openchoreo.dev/v1alpha1
    kind: Component
    metadata:
      name: checkout-service
    spec:
      componentType: deployment/web-app
      parameters: { ... }
      addons:
        - name: persistent-volume-claim
          instanceName: app-data
          config: { ... }

  addons:
    - apiVersion: openchoreo.dev/v1alpha1
      kind: Addon
      metadata:
        name: persistent-volume-claim
        namespace: default
      spec:
        creates: [...]
        patches: [...]

  workload:
    apiVersion: openchoreo.dev/v1alpha1
    kind: Workload
    metadata:
      name: checkout-service
    spec:
      image: gcr.io/project/checkout-service:v1.2.3
      endpoints: [...]
      connections: [...]
```
