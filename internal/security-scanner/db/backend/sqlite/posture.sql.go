// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: posture.sql

package sqlite

import (
	"context"
	"database/sql"
)

const countResourcesWithPostureFindings = `-- name: CountResourcesWithPostureFindings :one
SELECT COUNT(DISTINCT r.id) as count
FROM resources r
JOIN posture_findings f ON r.id = f.resource_id
`

func (q *Queries) CountResourcesWithPostureFindings(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countResourcesWithPostureFindings)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deletePostureFindingsByResourceID = `-- name: DeletePostureFindingsByResourceID :exec
DELETE FROM posture_findings WHERE resource_id = ?
`

func (q *Queries) DeletePostureFindingsByResourceID(ctx context.Context, resourceID int64) error {
	_, err := q.db.ExecContext(ctx, deletePostureFindingsByResourceID, resourceID)
	return err
}

const getPostureFindingsByResourceID = `-- name: GetPostureFindingsByResourceID :many
SELECT id, resource_id, check_id, check_name, severity, category, description, remediation, resource_version, created_at FROM posture_findings WHERE resource_id = ? ORDER BY created_at DESC
`

func (q *Queries) GetPostureFindingsByResourceID(ctx context.Context, resourceID int64) ([]PostureFinding, error) {
	rows, err := q.db.QueryContext(ctx, getPostureFindingsByResourceID, resourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PostureFinding{}
	for rows.Next() {
		var i PostureFinding
		if err := rows.Scan(
			&i.ID,
			&i.ResourceID,
			&i.CheckID,
			&i.CheckName,
			&i.Severity,
			&i.Category,
			&i.Description,
			&i.Remediation,
			&i.ResourceVersion,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostureScannedResource = `-- name: GetPostureScannedResource :one
SELECT psr.id, psr.resource_id, psr.resource_version, psr.scan_duration_ms, psr.scanned_at 
FROM posture_scanned_resources psr
JOIN resources r ON psr.resource_id = r.id
WHERE r.resource_type = ? AND r.resource_namespace = ? AND r.resource_name = ?
`

type GetPostureScannedResourceParams struct {
	ResourceType      string `json:"resource_type"`
	ResourceNamespace string `json:"resource_namespace"`
	ResourceName      string `json:"resource_name"`
}

func (q *Queries) GetPostureScannedResource(ctx context.Context, arg GetPostureScannedResourceParams) (PostureScannedResource, error) {
	row := q.db.QueryRowContext(ctx, getPostureScannedResource, arg.ResourceType, arg.ResourceNamespace, arg.ResourceName)
	var i PostureScannedResource
	err := row.Scan(
		&i.ID,
		&i.ResourceID,
		&i.ResourceVersion,
		&i.ScanDurationMs,
		&i.ScannedAt,
	)
	return i, err
}

const insertPostureFinding = `-- name: InsertPostureFinding :exec
INSERT INTO posture_findings (resource_id, check_id, check_name, severity, category, description, remediation, resource_version)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertPostureFindingParams struct {
	ResourceID      int64          `json:"resource_id"`
	CheckID         string         `json:"check_id"`
	CheckName       string         `json:"check_name"`
	Severity        string         `json:"severity"`
	Category        sql.NullString `json:"category"`
	Description     sql.NullString `json:"description"`
	Remediation     sql.NullString `json:"remediation"`
	ResourceVersion string         `json:"resource_version"`
}

func (q *Queries) InsertPostureFinding(ctx context.Context, arg InsertPostureFindingParams) error {
	_, err := q.db.ExecContext(ctx, insertPostureFinding,
		arg.ResourceID,
		arg.CheckID,
		arg.CheckName,
		arg.Severity,
		arg.Category,
		arg.Description,
		arg.Remediation,
		arg.ResourceVersion,
	)
	return err
}

const listPostureFindings = `-- name: ListPostureFindings :many
SELECT f.id, f.resource_id, f.check_id, f.check_name, f.severity, f.category, f.description, f.remediation, f.resource_version, f.created_at, r.resource_type, r.resource_namespace, r.resource_name
FROM posture_findings f
JOIN resources r ON f.resource_id = r.id
ORDER BY f.created_at DESC
LIMIT ? OFFSET ?
`

type ListPostureFindingsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListPostureFindingsRow struct {
	ID                int64          `json:"id"`
	ResourceID        int64          `json:"resource_id"`
	CheckID           string         `json:"check_id"`
	CheckName         string         `json:"check_name"`
	Severity          string         `json:"severity"`
	Category          sql.NullString `json:"category"`
	Description       sql.NullString `json:"description"`
	Remediation       sql.NullString `json:"remediation"`
	ResourceVersion   string         `json:"resource_version"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	ResourceType      string         `json:"resource_type"`
	ResourceNamespace string         `json:"resource_namespace"`
	ResourceName      string         `json:"resource_name"`
}

func (q *Queries) ListPostureFindings(ctx context.Context, arg ListPostureFindingsParams) ([]ListPostureFindingsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostureFindings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostureFindingsRow{}
	for rows.Next() {
		var i ListPostureFindingsRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceID,
			&i.CheckID,
			&i.CheckName,
			&i.Severity,
			&i.Category,
			&i.Description,
			&i.Remediation,
			&i.ResourceVersion,
			&i.CreatedAt,
			&i.ResourceType,
			&i.ResourceNamespace,
			&i.ResourceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourcesWithPostureFindings = `-- name: ListResourcesWithPostureFindings :many
SELECT DISTINCT r.id, r.resource_type, r.resource_namespace, r.resource_name, r.resource_uid, r.resource_version, r.created_at, r.updated_at
FROM resources r
JOIN posture_findings f ON r.id = f.resource_id
ORDER BY r.updated_at DESC
LIMIT ? OFFSET ?
`

type ListResourcesWithPostureFindingsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListResourcesWithPostureFindings(ctx context.Context, arg ListResourcesWithPostureFindingsParams) ([]Resource, error) {
	rows, err := q.db.QueryContext(ctx, listResourcesWithPostureFindings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Resource{}
	for rows.Next() {
		var i Resource
		if err := rows.Scan(
			&i.ID,
			&i.ResourceType,
			&i.ResourceNamespace,
			&i.ResourceName,
			&i.ResourceUid,
			&i.ResourceVersion,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertPostureScannedResource = `-- name: UpsertPostureScannedResource :exec
INSERT INTO posture_scanned_resources (resource_id, resource_version, scan_duration_ms, scanned_at)
VALUES (?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(resource_id) DO UPDATE SET 
  resource_version = excluded.resource_version,
  scan_duration_ms = excluded.scan_duration_ms,
  scanned_at = CURRENT_TIMESTAMP
`

type UpsertPostureScannedResourceParams struct {
	ResourceID      int64         `json:"resource_id"`
	ResourceVersion string        `json:"resource_version"`
	ScanDurationMs  sql.NullInt64 `json:"scan_duration_ms"`
}

func (q *Queries) UpsertPostureScannedResource(ctx context.Context, arg UpsertPostureScannedResourceParams) error {
	_, err := q.db.ExecContext(ctx, upsertPostureScannedResource, arg.ResourceID, arg.ResourceVersion, arg.ScanDurationMs)
	return err
}
